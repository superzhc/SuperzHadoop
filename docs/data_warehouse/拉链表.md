# 拉链表

> 拉链表是针对数据仓库设计中表存储数据的方式而定义的，顾名思义，所谓拉链，就是记录历史。记录一个事物从开始，一直到当前状态的所有变化的信息

## 拉链表的使用场景

在数据仓库的数据模型设计过程中，经常会遇到下面这种表的设计：
1. 有一些表的数据量很大，比如一张用户表，大约 10 亿条记录，50 个字段，这种表，即使使用 Orc 压缩，单张表的存储也会超过 100G，在 Hdfs 使用双备份或者三备份的话就更大一些；
2. 表中的部分字段会被 Update 更新操作，如用户联系方式，产品的描述信息，订单的状态等等；
3. 需要查看某一个时间点或者时间段的历史快照信息，比如，查看某一个订单在历史某一个时间点的状态；
4. 表中的记录变化的比例和频率不是很大，比如，总共有 10 亿的用户，每天新增和发生变化的有 200 万左右，变化的比例占的很小。

对于上面的案例，有以下几种方案可选：
- 方案一：每天只留最新的一份，比如每天用 Sqoop 抽取最新的一份全量数据到 Hive 中
- 方案二：每天保留一份全量的切片数据
- 方案三：使用拉链表

对上面三种方案进行逐个分析，分析结果如下：
- 方案一：
    ```
    这种方案需要每天 Drop 掉前一天的数据，重新抽一份最新的。
    优点很明显，节省空间，一些普通的使用也很方便，不用在选择表的时候加一个时间分区什么的。
    缺点同样明显，没有历史数据，先翻翻旧账只能通过其它方式，比如从流水表里面抽。
    ```
- 方案二：
    ```
    缺点同样明显，没有历史数据，先翻翻旧账只能通过其它方式，比如从流水表里面抽。
    缺点就是存储空间占用量太大太大了，如果对这边表每天都保留一份全量，那么每次全量中会保存很多不变的信息，对存储是极大的浪费。
    ```
- 方案三：
    ```
    首先它在空间上做了一个取舍，虽说不像方案一那样占用量那么小，但是它每日的增量可能只有方案二的千分之一甚至是万分之一。
    其实它能满足方案二所能满足的需求，既能获取最新的数据，也能添加筛选条件也获取历史的数据。所以在一些场景下，拉链表是能解决很多问题的。
    ```

## 拉链表的设计和实现

### 设计一张拉链表

示例：

在 `2017-01-01` 这一天表中的数据是：

| 注册日期   | 用户编号 | 手机号码 |
| ---------- | -------- | -------- |
| 2017-01-01 | 001      | 111111   |
| 2017-01-01 | 002      | 222222   |
| 2017-01-01 | 003      | 333333   |
| 2017-01-01 | 004      | 444444   |

在 `2017-01-02` 这一天表中的数据是， 用户 002 和 004 资料进行了修改，005 是新增用户：

| 注册日期   | 用户编号 | 手机号码 | 备注                   |
| ---------- | -------- | -------- | ---------------------- |
| 2017-01-01 | 001      | 111111   |                        |
| 2017-01-01 | 002      | 233333   | （由222222变成233333） |
| 2017-01-01 | 003      | 333333   |                        |
| 2017-01-01 | 004      | 432432   | （由444444变成432432） |
| 2017-01-02 | 005      | 555555   | （2017-01-02新增）     |

在 2017-01-03 这一天表中的数据是， 用户 004 和 005 资料进行了修改，006 是新增用户：

| 注册日期   | 用户编号 | 手机号码 | 备注                   |
| ---------- | -------- | -------- | ---------------------- |
| 2017-01-01 | 001      | 111111   |                        |
| 2017-01-01 | 002      | 233333   |                        |
| 2017-01-01 | 003      | 333333   |                        |
| 2017-01-01 | 004      | 654321   | （由432432变成654321） |
| 2017-01-02 | 005      | 115115   | （由555555变成115115） |
| 2017-01-03 | 006      | 666666   | （2017-01-03新增）     |

如果在数据仓库中设计成历史拉链表保存该表，则会有下面这样一张表，这是最新一天（即 2017-01-03 ）的数据：

| 注册日期   | 用户编号 | 手机号码 | t_start_date | t_end_date |
| ---------- | -------- | -------- | ------------ | ---------- |
| 2017-01-01 | 001      | 111111   | 2017-01-01   | 9999-12-31 |
| 2017-01-01 | 002      | 222222   | 2017-01-01   | 2017-01-01 |
| 2017-01-01 | 002      | 233333   | 2017-01-02   | 9999-12-31 |
| 2017-01-01 | 003      | 333333   | 2017-01-01   | 9999-12-31 |
| 2017-01-01 | 004      | 444444   | 2017-01-01   | 2017-01-01 |
| 2017-01-01 | 004      | 432432   | 2017-01-02   | 2017-01-02 |
| 2017-01-01 | 004      | 654321   | 2017-01-03   | 9999-12-31 |
| 2017-01-02 | 005      | 555555   | 2017-01-02   | 2017-01-02 |
| 2017-01-02 | 005      | 115115   | 2017-01-03   | 9999-12-31 |
| 2017-01-03 | 006      | 666666   | 2017-01-03   | 9999-12-31 |

- t_start_date 表示该条记录的生命周期开始时间
- t_end_date 表示该条记录的生命周期结束时间
- `t_end_date = '9999-12-31'` 表示该条记录目前处于有效状态
- 如果查询当前所有有效的记录，则 `select * from user where t_end_date = '9999-12-31'`
- 如果查询 `2017-01-02` 的历史快照，则 `select * from user where t_start_date <= '2017-01-02' and t_end_date >= '2017-01-02'`

### 在 Hive 中实现拉链表

示例：**以上面的用户表为例，来实现用户的拉链表**。

**前提**

在实现之前，需要先确定有以下的数据源：
- 一张 ODS 层的用户全量表
- 每日的用户更新表

> 而且要确定拉链表的时间粒度，比如说拉链表每天只取一个状态，也就是说如果一天有 3 个状态变更，只取最后一个状态，这种天粒度的表其实已经能解决大部分的问题了。

> 每日的用户更新表的获取方法，有以下 3 种方式来获取：
> 1. 可以监听 Mysql 库数据的变化，比如说用 Canal，最后合并每日的变化，获取到最后的一个状态
> 2. 假设我们每天都会获得一份切片数据，我们可以通过取两天切片数据的不同来作为每日更新表，这种情况下我们可以对所有的字段先进行 concat，再取 md5，这样就 ok 了
> 3. 流水表，有每日的变更流水表

**ODS 层的 User 表**

```sql
CREATE EXTERNAL TABLE ods.user (
  user_num STRING COMMENT '用户编号',
  mobile STRING COMMENT '手机号码',
  reg_date STRING COMMENT '注册日期'
COMMENT '用户资料表'
PARTITIONED BY (dt string)
ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t' LINES TERMINATED BY '\n'
STORED AS ORC
LOCATION '/ods/user';
)
```

**ODS 层的 User_Update 表**

```sql
CREATE EXTERNAL TABLE ods.user_update (
  user_num STRING COMMENT '用户编号',
  mobile STRING COMMENT '手机号码',
  reg_date STRING COMMENT '注册日期'
COMMENT '每日用户资料更新表'
PARTITIONED BY (dt string)
ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t' LINES TERMINATED BY '\n'
STORED AS ORC
LOCATION '/ods/user_update';
)
```

**拉链表**

```sql
CREATE EXTERNAL TABLE dws.user_his (
  user_num STRING COMMENT '用户编号',
  mobile STRING COMMENT '手机号码',
  reg_date STRING COMMENT '用户编号',
  t_start_date ,
  t_end_date
COMMENT '用户资料拉链表'
ROW FORMAT DELIMITED FIELDS TERMINATED BY '\t' LINES TERMINATED BY '\n'
STORED AS ORC
LOCATION '/dws/user_his';
)
```

**实现 sql 语句**

现在假设已经初始化了 `2017-01-01` 的日期，然后需要更新 `2017-01-02` 那一天的数据，获取拉链表数据的sql：

```sql
INSERT OVERWRITE TABLE dws.user_his
SELECT * FROM
(
    SELECT A.user_num,
           A.mobile,
           A.reg_date,
           A.t_start_time,
           CASE
                WHEN A.t_end_time = '9999-12-31' AND B.user_num IS NOT NULL THEN '2017-01-01' --结束时间可设置成变量，用当前执行的时间
                ELSE A.t_end_time
           END AS t_end_time
    FROM dws.user_his AS A
    LEFT JOIN ods.user_update AS B
    ON A.user_num = B.user_num
UNION
    SELECT C.user_num,
           C.mobile,
           C.reg_date,
           '2017-01-02' AS t_start_time,
           '9999-12-31' AS t_end_time
    FROM ods.user_update AS C
) AS T
```

## 其他

### 查询性能

拉链表当然也会遇到查询性能的问题，比如说存放了5年的拉链数据，那么这张表势必会比较大，当查询的时候性能就比较低了，一般有两个思路来解决：
- 在一些查询引擎中，对 `start_date` 和 `end_date` 做索引，这样能提高不少性能。这种方法其实在 Hive 中行不通，因为 Hive 相当于没有索引，不过在其它系统中可以考虑。
- 保留部分历史数据，比如说一张表里面存放全量的拉链表数据，然后再对外暴露一张只提供近 3 个月数据的拉链表【也就是使用两张表，一张是全量表，一张是部分数据表】

### 淘汰机制

关于淘汰机制，其实和性能也是有关系的，一方面是因为所有数据的积累会导致计算越来越慢，另一方面是业务侧其实对历史数据的需求也有一定的优先级的。

因此在设计拉链表的时候可以制定一些数据的淘汰机制。淘汰的数据不一定要删除，比如建立两张拉链表，一张拉链表中只保存最新的十条数据，其它的数据会存入一张历史拉链表中。