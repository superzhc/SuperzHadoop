# 模型

> 在 pydantic 中定义对象的主要方法是通过模型(模型只是继承自 `BaseModel` 的类)

## BaseModel 基本模型

```py
from pydantic import BaseModel

class User(BaseModel):
    # 整数类型，未设置默认值，初始化时需传递该值
    id: int
    name = "superz"

# 实例化
user=User(id=1)
```

> 实例化将执行所有解析和验证，如果有错误则会触发 ValidationError 报错。

模型具有以下属性：

| 属性             | 描述                                                                                         | 备注 |
| ---------------- | -------------------------------------------------------------------------------------------- | ---- |
| `dict()`         | 模型字段和值的字典                                                                           |      |
| `json()`         | JSON 字符串表示 `dict()`                                                                     |      |
| `copy()`         | 模型的副本（默认为浅表副本）                                                                 |      |
| `parse_obj()`    | 使用 dict 解析数据                                                                           |      |
| `parse_raw()`    | 将 str 或 bytes 并将其解析为 json，然后将结果传递给 `parse_obj()`                            |      |
| `parse_file()`   | 文件路径，读取文件并将内容传递给 `parse_raw()`。如果 content_type 省略，则从文件的扩展名推断 |      |
| `from_orm()`     | 从 ORM 对象创建模型                                                                          |      |
| `schema()`       | 返回模式的字典                                                                               |      |
| `schema_json()`  | 返回该字典的 JSON 字符串表示                                                                 |      |
| `construct()`    | 允许在没有验证的情况下创建模型                                                               |      |
| `__fields_set__` | 初始化模型实例时需设置的字段名称集                                                           |      |
| `__fields__`     | 模型字段的字典                                                                               |      |
| `__config__`     | 模型的配置类                                                                                 |      |

## 递归模型

> 可以通过在注解中使用模型本身作为类型来定义更复杂的分层数据结构

## 泛型模型

pydantic 支持创建泛型模型，以便更容易重用公共模型结构。

为了声明泛型模型，必须执行下面的步骤：

1. 声明一个或多个 `typing.TypeVar` 实例来参数化模型
2. 声明一个继承自 `pydantic.generics.GenericModel` 和 `typing.Generic` 的 pydantic 模型，其中将 TypeVar 实例作为参数传递给 `typing.Generic` 
3. 使用 TypeVar 实例对将要使用其他类型或 pydantic 模型进行替换的字段进行注解

## 动态模型

> pydantic 提供了 create_model 方法来允许动态创建模型。

```py
from pydantic import BaseModel, create_model

DynamicFoobarModel = create_model('DynamicFoobarModel', foo=(str, ...), bar=123)

class StaticFoobarModel(BaseModel):
    foo: str
    bar: int = 123

# StaticFooBarModel 和 DynamicFooBarModel 是相同的
```

## 自定义根类型

可以通过声明 `__root__` 字段来使用自定义根类型定义 Pydantic 模型。

根类型可以是 pydantic 支持的任意类型，该类型通过 `__root__` 字段上的类型提示来指定。根值可以通过模型的 `__init__` 方法的 `__root__` 参数传递，或者作为 `parse_obj` 的第一个且唯一的一个参数。

```py

```