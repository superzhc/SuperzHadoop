# 模块

## 模块搜索路径

加载模块时，解释器会搜索 `sys.path` 中的目录列表。`sys.path` 中的第一个条目通常是一个空字符串 `''` ，表示 *当前正在使用的目录*。`sys.path` 中的其他条目可能包含目录名称、`.zip` 压缩文件和 `.egg` 文件。各个条目在 `sys.path` 中排列的顺序决定了加载模块时的搜索顺序。要将新条目添加到搜索路径中，只需将它们添加到该列表中即可。

尽管该路径通常包含目录名称，也可以将包含 Python 模块的 zip 压缩文件添加到搜索路径中。通过这种方式，可以方便地将一组模块打包为一个文件。例如，假设创建了两个模块 `foo.py` 和 `bar.py` ，并将它们放在一个名为 `mymodules.zip` 的 zip 文件中。就可以按如下方式将这个文件添加到 Python 搜索路径中：

```py
import sys
sys.path.append("mymodules.zip")
import foo, bar
```

也可以使用 zip 文件目录结构中的具体位置。另外，zip 文件可以与常规路径名称混合使用，例如：

```py
sys.path.append("/tmp/modules.zip/lib/python")
```

除了 `.zip` 文件，还可以在搜索路径中添加 `.egg` 文件。`.egg` 文件是由 setuptools 库创建的包。这是安装第三方 Python 库和扩展时会碰到的一种常见格式。`.egg` 文件实际上只是添加了额外的元数据（如版本号、依赖关系等）的 `.zip` 文件。因此，可以使用处理 `.zip` 文件的标准工具来从 `.egg` 文件中检查和提取数据。

尽管支持 zip 文件导入，还是有一些限制需要注意。首先，只能从压缩文件中导入 `.py` 、`.pyw` 、`.pyc` 和 `.pyo` 文件。使用 C 编写的共享库和扩展模块无法直接从压缩文件中加载，尽管 setuptools 等打包系统有时能够提供一种变通方案（通常将 C 扩展提取到一个临时目录并从该目录加载模块）。而且，从压缩文件加载 `.py` 文件时，Python 不会创建 `.pyc` 和 `.pyo` 文件。因此，一定要确保提前创建了这些文件，并将其放在归档文件中，以避免在加载模块时性能下降。

## 模块加载和编译

使用 import 加载的模块实际上可分为 4 个通用类别：

- 使用 Python 编写的代码（`.py` 文件）；
- 已被编译为共享库或 DLL 的 C 或 C++ 扩展；
- 包含一组模块的包；
- 使用 C 编写并链接到 Python 解释器的内置模块。

查找模块（如 foo）时，解释器在 `sys.path` 中的每个目录下搜索以下文件（按搜索顺序列出）：

1. 目录 foo，它定义了一个包
2. `foo.pyd` 、`foo.so` 、`foomodule.so` 或 `foomodule.dll`（已编译的扩展）
3. `foo.pyo` （只适用于使用了 `-O` 或 `-OO` 选项时）
4. `foo.pyc`
5. `foo.py` （在 Windows 上，Python 还会查找 `.pyw` 文件。）

对于 `.py` 文件，首次导入模块时，它会被编译为字节码并作为 `.pyc` 文件写回磁盘。在后续的导入操作中，解释器将加载这段预编译的字节码，除非 `.py` 文件有最新的修改（在这种情况下，将重新生成 `.pyc` 文件）。`.pyo` 文件与解释器的 `-O` 选项结合使用。这些文件包含已删除了行号、断言和其他调试信息的字节码。因此，这些文件会相对更小，解释器的运行速度也会稍快一些。如果指定了 `-OO `选项，而不是 `-O` ，那么还会从文件中删除文档字符串。文档字符串只会在创建 `.pyo` 文件时删除，而不是在加载它们的时候。如果 `sys.path` 中的所有目录下都不存在这些文件，解释器将检查该名称是否为内置的模块名称。如果不存在匹配的名称，将引发 importError 异常。

只有使用 import 语句才能将文件自动编译为 `.pyc` 和 `.pyo` 文件。在命令行或标准输入中指定的程序不会生成这类文件。另外，如果包含模块的 `.py` 文件的目录不允许写入（例如，可能是由于权限不够或者该文件包含在一个 zip 归档文件中），将不会创建这些文件。解释器的 `-B` 选项也可以禁止生成这些文件。

如果存在 `.pyc` 和 `.pyo` 文件，则可以没有相应的 `.py` 文件。因此，如果在打包代码时不希望包含源文件，可以只打包一组 `.pyc` 文件。但是请注意，Python 提供了对内省（introspection）和分解的广泛支持。即使没有提供源文件，细心的用户仍然可以检查并发现程序的大量细节。还请注意，`.pyc` 文件特定于具体的 Python 版本。因此，为某个 Python 版本生成的 `.pyc` 文件可能不适用于未来的 Python 版本。

import 语句搜索文件时，文件名匹配是区分大小写的，即使机器上的底层文件系统不区分大小写也是如此，如 Windows 和 OS X（不过这些系统会保留名称的大小写形式）。所以，import foo 将只导入文件 `foo.py` ，不会导入文件 `FOO.PY` 。但是，作为一般规则，应该避免使用仅大小写形式不同的模块名称。

## `__name__`

每个模块会定义一个包含模块名称的变量 `__name__`。程序可以检查该变量，以确定它们在哪个模块中执行。解释器的顶层模块名为 `__main__`。

## `__all__`

> 通过定义列表 `__all__` ，模块可以精确控制 `from module import *` 导入的名称集合

```py
# 模块：spam.py
__all__ = [ 'bar', 'Spam' ]　# 将使用 from spam import * 导出的名称
```