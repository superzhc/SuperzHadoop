# 类型注释/类型注解/类型标注

> Python3.5 新增功能，源码：[Lib/typing.py](https://github.com/python/cpython/tree/3.10/Lib/typing.py)
>
> 这个模块提供对类型提示的运行时支持。最基本的支持包括 `Any` , `Union` , `Callable` , `TypeVar` 和 `Generic` 。关于完整的规范，请参考 [PEP 484](https://www.python.org/dev/peps/pep-0484)。关于类型提示的简化介绍，请参考 [PEP 483](https://www.python.org/dev/peps/pep-0483)。
>
> Python 运行时不强制执行函数和变量类型注解，但这些注解可用于类型检查器、IDE、静态检查器等第三方工具。
>
> 相关的 PEP：<https://docs.python.org/zh-cn/3.10/library/typing.html#relevant-peps>

## 创建类型

> 使用 NewType 创建不同的类型

```py
from typing import NewType

UserId = NewType('UserId', int)
some_id = UserId(123)
```

## 类型别名

> 将类型赋值给变量，该变量就被定义为类型的别名

```py
Vector=list[float]
```

> 类型别名可用于简化复杂类型签名。

## 泛型

容器中对象的类型信息不能以泛型方式静态推断，因此抽象基类扩展支持下标，用于表示容器元素的预期类型。

```py
from collections.abc import Mapping, Sequence

def notify_by_email(employees: Sequence[Employee],
                    overrides: Mapping[str, str]) -> None: ...
```

**泛型函数**

typing 模块中推出的 TypeVar 工厂函数实现泛型参数化

```py
from collections.abc import Sequence
from typing import TypeVar

T = TypeVar('T')      # Declare type variable

def first(l: Sequence[T]) -> T:   # Generic function
    return l[0]
```

**泛型类**

<!-- TODO -->

一个泛型可以有任何数量的类型变量。所有种类的 TypeVar 都可以作为泛型的参数:

```py
from typing import TypeVar, Generic, Sequence

T = TypeVar('T', contravariant=True)
B = TypeVar('B', bound=Sequence[bytes], covariant=True)
S = TypeVar('S', int, str)

class WeirdTrio(Generic[T, B, S]):...
```