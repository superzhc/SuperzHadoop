# 类型注解

> 变量注解实际上只是一种类型提示，对运行实际上是没有影响

## 使用

```py
# 定义一个变量
x: int = 2
x: int | float = 2 # 表示 or Python 3.10 开始支持
x + 1
# 3

# 定义一个除法函数
def div(a: int, b: int) -> float:
    return a/b

# 查看类型注解信息；函数注解的信息，保存在 __annotations__ 属性中可以来调用。
div.__annotations__
{'a': int, 'b': int, 'return': float}
```

**语法**

- 变量类型：在变量名后加一个冒号，冒号后写变量的数据类型，如 int、dict 等
- 函数返回类型：方法参数中如变量类型，在参数括号后加一个箭头，箭头后返回值的类型
- 格式要求（PEP 8，非强制）：变量名和冒号无空格，冒号和后边类型间加一个空格，箭头左右均有一个空格

## 类型

| 类型      | 描述   |
| --------- | ------ |
| int       | 整型   |
| long      | 长整型 |
| float     | 浮点型 |
| bool      | 布尔型 |
| str       | 字符串 |
| list      | 列表   |
| tuple     | 元组   |
| dict      | 字典   |
| set       | 集合   |
| Iterable  | 可迭代 |
| Iterator  | 迭代器 |
| Generator | 生成器 |

> python3.9 以后可以直接使用 list, dict, set, tuple 等类型，3.9 以前可能需要 from typing import List, Dict, Set, Tuple

**类型别名**

```py
from typing import TypeAlias

Factors: TypeAlias = list[int]  # 相当于 Factors = list[int]
```

**Literal**

字面量类型，只接受指定的内容

```py
from typing import Literal

M = Literal['r','w','rb']  # 用户输入别的内容，会进行代码提示

def test(mode: M):
    pass

test('xb')  # Expected type 'Literal['r', 'w', 'rb']', got 'Literal['xb']' instead 
```

**Optional**

这个类型代表的是当前参数是一个可选参数，只能接受一种类型，`Optional[X]` 等同于 `X | None` (或者 `Union[X, None]`)，也就说是，它默认包含了 None：

```py
from typing import Optional

def test(x: Optional[int]=1):
    return x
```