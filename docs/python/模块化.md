# 模块化

## 模块

模块是一个包含 Python 定义和语句的文件。文件名就是模块名后跟文件后缀 `.py` 。在一个模块内部，模块名（作为一个字符串）可以通过全局变量 `__name__` 的值获得。

模块可以包含可执行的语句以及函数定义。这些语句用于初始化模块。它们仅在模块 *第一次* 在 import 语句中被导入时才执行。 

每个模块都有它自己的私有符号表，该表用作模块中定义的所有函数的全局符号表。因此，模块的作者可以在模块内使用全局变量，而不必担心与用户的全局变量发生意外冲突。另一方面，如果你知道自己在做什么，则可以用跟访问模块内的函数的同样标记方法，去访问一个模块的全局变量，modname.itemname。

模块可以导入其它模块。习惯上但不要求把所有 [`import`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import) 语句放在模块（或脚本）的开头。被导入的模块名存放在调入模块的全局符号表中。

[`import`](https://docs.python.org/zh-cn/3/reference/simple_stmts.html#import) 语句有一个变体，它可以把名字从一个被调模块内直接导入到现模块的符号表里。例如:

```python
from fibo import fib, fib2
fib(500)
```

## `import` 用法

主要有以下两种：

- `import 模块名1 [as 别名1], 模块名2 [as 别名2]，…`：使用这种语法格式的 import 语句，会导入指定模块中的所有成员（包括变量、函数、类等）。不仅如此，当需要使用模块中的成员时，需用该模块名（或别名）作为前缀，否则 Python 解释器会报错。
- `from 模块名 import 成员名1 [as 别名1]，成员名2 [as 别名2]，…`： 使用这种语法格式的 import 语句，只会导入模块中指定的成员，而不是全部成员。同时，当程序中使用该成员时，无需附加任何前缀，直接使用成员名（或别名）即可。

### `__import__()`

`__import__()` 函数可用于导入模块。其实当使用 import 导入 Python 模块的时候，默认调用的是 `__import__()` 函数。直接使用该函数的情况很少见，一般用于动态加载模块。

`__import__(name, globals=None, locals=None, fromlist=(), level=0)` 参数：

- name：要导入的模块名，可使用变量
- globals 和 locals：通常使用默认值。使用给定的 globals 和 locals 变量来决定如何在一个包上下文中解析 name
- fromlist：指定要导入的子模块名或对象名，它们会按名称从模块导入
- leve：指定导入模块的方式。level为0则绝对导入; level 为正值则表示相对于调用 `__import __()` 的模块目录，要搜索的父目录树

```py
os_obj = __import__("os")
print(os_obj.getcwd())
```


## 导入模块

通常情况下，当使用 import 语句导入模块后，Python 会按照以下顺序查找指定的模块文件：

1. 在当前目录，即当前执行的程序文件所在目录下查找；
2. 到 `PYTHONPATH`（环境变量）下的每个目录中查找；
3. 到 Python 默认的安装目录下查找。

以上所有涉及到的目录，都保存在标准模块 sys 的 `sys.path` 变量中，通过此变量我们可以看到指定程序文件支持查找的所有目录。换句话说，如果要导入的模块没有存储在 `sys.path` 显示的目录中，那么导入该模块并运行程序时，Python 解释器就会抛出 ModuleNotFoundError（未找到模块）异常。

解决“Python找不到指定模块”的方法有 3 种，分别是：

- 向 `sys.path` 中临时添加模块文件存储位置的完整路径；
  ```py
  # 模块文件的存储位置，可以临时添加到 sys.path 变量中，即向 sys.path 中添加 D:\\custom_python_package
  import sys
  print(sys.path)
  # 结果：['', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python36.zip', '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6', ..., '/Library/Frameworks/Python.framework/Versions/3.6/lib/python3.6/site-packages']
  sys.path.append('D:\\custom_python_package')
  ```
- 将模块放在 `sys.path` 变量中已包含的模块加载路径中；
- 设置 path 系统环境变量。

## `__all__` 变量

`__all__` 变量的值是一个列表，存储的是当前模块中一些成员（变量、函数或者类）的名称。通过在模块文件中设置 `__all__` 变量，当其它文件以 `from 模块名 import *` 的形式导入该模块时，该文件中只能使用 `__all__` 列表中指定的成员。

> 也就是说，只有以 `from 模块名 import *` 形式导入的模块，当该模块设有 `__all__` 变量时，只能导入该变量指定的成员，未指定的成员是无法导入的。

再次声明，`__all__` 变量仅限于在其它文件中以 `from 模块名 import *` 的方式引入。也就是说，如果使用以下 2 种方式引入模块，则 `__all__` 变量的设置是无效的。

- 以 `import 模块名` 的形式导入模块。通过该方式导入模块后，总可以通过模块名前缀（如果为模块指定了别名，则可以使用模快的别名作为前缀）来调用模块内的所有成员（除了以下划线开头命名的成员）。
- 以 `from 模块名 import 成员` 的形式直接导入指定成员。使用此方式导入的模块，`__all__` 变量即便设置，也形同虚设。

## 导入包

导入方法可归结为以下 3 种：

- `import 包名[.模块名 [as 别名]]`
- `from 包名 import 模块名 [as 别名]`
- `from 包名.模块名 import 成员名 [as 别名]`