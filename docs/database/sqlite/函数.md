# 函数

## 条件判断函数

| 函数       | 描述                                                                                              |
| ---------- | ------------------------------------------------------------------------------------------------- |
| `coalesce` | 返回参数列表中第一个不是 NULL 的值                                                                |
| `ifnull`   | 如果第一个参数为 NULL，返回第二个参数，否则返回第一个参数                                         |
| `iif`      | 如果第一个参数是真，返回第二个参数，否则返回第三个参数                                            |
| `nullif`   | 根据两个参数是否相等决定返回 NULL 还是第一个参数。如果两个参数相同，返回 NULL，否则返回第一个参数 |

## 时间函数

| 函数                                         | 描述                                                             |
| -------------------------------------------- | ---------------------------------------------------------------- |
| `date(timestring[,modifier...])`             | 以 `YYYY-MM-DD` 格式返回日期                                     |
| `time(timestring[,modifier...])`             | 以 `HH:MM:SS` 格式返回时间                                       |
| `datetime(timestring[,modifier...])`         | 以 `YYYY-MM-DD HH:MM:SS` 格式返回                                |
| `julianday(timestring[,modifier...])`        | 这将返回从格林尼治时间的公元前 4714 年 11 月 24 日正午算起的天数 |
| `strftime(format, timestring[,modifier...])` | 这将根据第一个参数指定的格式字符串返回格式化的日期               |

**修饰符（Modifier）**

时间函数的参数中可带有零个或多个的修饰符，修饰符应从左到右使用，下面列出了可在 SQLite 中使用的修饰符：

- `NNN days`
- `NNN hours`
- `NNN minutes`
- `NNN.NNNN seconds`
- `NNN months`
- `NNN years`
- `start of month`
- `start of year`
- `start of day`
- `weekday N`
- `unixepoch`
- `localtime`
- `utc`

**示例**

```sql
-- 下面是计算当前日期：
SELECT date('now');
-- 2013-05-07

-- 下面是计算当前月份的最后一天：
SELECT date('now','start of month','+1 month','-1 day');
-- 2013-05-31

-- 下面是计算给定 UNIX 时间戳 1092941466 的日期和时间：
SELECT datetime(1092941466, 'unixepoch');
-- 2004-08-19 18:51:06

-- 下面是计算给定 UNIX 时间戳 1092941466 相对本地时区的日期和时间：
SELECT datetime(1092941466, 'unixepoch', 'localtime');
-- 2004-08-19 11:51:06

-- 下面是计算当前的 UNIX 时间戳：
SELECT strftime('%s','now');
-- 1367926057

-- 下面是计算时间差天数：
SELECT julianday('now') - julianday('1776-07-04');
-- 86504.4775830326

-- 下面是计算从 2004 年某一特定时刻以来的秒数：
SELECT strftime('%s','now') - strftime('%s','2004-01-01 02:34:56');
-- 295001572

-- 下面是计算当年 10 月的第一个星期二的日期：
SELECT date('now','start of year','+9 months','weekday 2');
-- 2013-10-01

-- 下面是计算从 UNIX 纪元算起的以秒为单位的时间（类似 strftime('%s','now') ，不同的是这里有包括小数部分）：
SELECT (julianday('now') - 2440587.5)*86400.0;
-- 1367926077.12598

-- 在 UTC 与本地时间值之间进行转换，当格式化日期时，使用 utc 或 localtime 修饰符，如下所示：
SELECT time('12:00', 'localtime');
-- 05:00:00
SELECT time('12:00', 'utc');
-- 19:00:00
```

## 字符串函数

| 函数        | 描述                                                                                                                                |
| ----------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| `format`    | 根据指定的模式格式化输出字符串，它与 C 语言中的 printf 函数类似                                                                     |
| `printf`    | 根据指定的模式格式化输出字符串，它与 C 语言中的 printf 函数类似                                                                     |
| `length`    | 返回给定的字符串的字符数量，或者返回给定 blob 值的字节数量                                                                          |
| `upper`     | 将给定的字符串转为大写并返回                                                                                                        |
| `lower`     | 将给定的字符串转为小写并返回                                                                                                        |
| `substr`    | 从一个指定的字符串中根据指定的起始位置和长度提取子字符串并返回                                                                      |
| `substring` | 从一个指定的字符串中根据指定的起始位置和长度提取子字符串并返回                                                                      |
| `instr`     | 在一个给定字符串中查找另一个给定的字符串的第一次出现的位置。如果找到，则返回一个表示第一次出现的位置的数字（从 1 开始），否则返回 0 |
| `replace`   | 将一个指定的字符串中出现的所有指定的子字符串替换为新的子字符串并返回结果                                                            |
| `trim`      | 从一个字符串的开头和结尾删除一个包含了由参数指定的所有字符（默认为空格）的最长的字符串                                              |
| `ltrim`     | 从一个字符串的左侧删除一个包含了由参数指定的所有字符（默认为空格）的最长的字符串                                                    |
| `rtrim`     | 从一个字符串的右侧删除一个包含了由参数指定的所有字符（默认为空格）的最长的字符串                                                    |
| `glob`      | 检查一个给定的字符串是否与给定的模式匹配                                                                                            |
| `like`      | 检查一个给定的字符串是否与给定的模式匹配                                                                                            |
| `quote`     | 将参数使用单引号包围起来，并将其作为 SQL 文本字面值返回                                                                             |

## Json 函数

| 函数                                | 描述                                                                                                                     |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------ |
| `json(json)`                        | 验证由参数指定的字符串，并将其转为最小化的 JSON 字符串（删除了多余的空白）                                               |
| `json_array(value1,value2,...)`     | 返回一个包含了所有参数的 JSON 数组                                                                                       |
| `json_array_length(json[,path])`    | 返回一个指定的 JSON 数组或者数组中通过路径指定的数组的元素数量                                                           |
| `json_each(json[,path])`            | 遍历指定 JSON 文档，为每个直接子元素生成一行                                                                             |
| `json_extract(json,path,...)`       | 在 JSON 文档提取路径表达式指定的数据并返回                                                                               |
| `json_object(label1,value1,...)`    | 返回一个包含了由参数指定的所有键值对的 JSON 对象                                                                         |
| `json_insert(json,path,value,...)`  | 向一个 JSON 文档中插入数据并返回新的 JSON 文档                                                                           |
| `json_remove(json,path,...)`        | 从一个 JSON 文档中删除由路径指定的数据并返回修改后的 JSON 文档                                                           |
| `json_patch(json1,json2)`           | 将第二个 JSON 对象合并补充到原 JSON 对象上，并返回合并补充后原 JSON 对象。如果两个参数不全是 JSON 对象，则返回第二个参数 |
| `json_replace(json,path,value,...)` | 在一个 JSON 文档中替换已存在的数据并返回新的 JSON 文档                                                                   |
| `json_set(json,path,value,...)`     | 在一个 JSON 文档中插入或更新数据并返回新的 JSON 文档                                                                     |
| `json_tree(json[,path])`            | 递归遍历指定 JSON 文档，为每个子元素生成一行（包括参数本身），最终返回由所有的行组成的结果集                             |
| `json_type(json[,path])`            | 返回一个给定的 JSON 或者 JSON 中指定路径的值的类型                                                                       |
| `json_valid(json)`                  | 返回 0 和 1 来指示给定的参数是否是一个有效的 JSON 文档                                                                   |
| `json_quote(value)`                 |                                                                                                                          |

**JSON参数**

对于接受 JSON 作为其第一个参数的函数，该参数可以是 JSON 对象、数组、数字、字符串或 null。

SQLite 数值和 NULL 值分别被解释为 JSON 数字和空值。

SQLite 文本值可以理解为 JSON 对象、数组或字符串。

如果将不是格式正确的 JSON 对象、数组或字符串的 SQLite 文本值传递给 JSON 函数，该函数会抛出错误。

**PATH参数**

对于接受 PATH 参数的函数,PATH 必须是正确格式,否则函数将抛出一个错误。

格式正确的 PATH 是一个文本值，它正好以一个 `$` 字符开头，后跟零个或多个 `.objectlabel` 或 `[arrayindex]` 的实例。

数组索引通常是非负整数 N。在这种情况下，所选的数组元素是数组的第 N 个元素，从左侧的零开始。数组索引也可以是 `#-N` 的形式，在这种情况下，所选元素是右侧的第 N 个元素。数组的最后一个元素是 `#-1`。将 `#`字符视为“数组中的元素数”。然后，表达式 `#-1` 的计算结果为与数组中最后一个条目对应的整数。数组索引有时只是 `#` 字符很有用，例如，在将值追加到现有 JSON 数组时：

```
json_set（'[0,1,2]','$[#]','new'） → '[0,1,2,"new"]'
```

**VALUE参数**

对于接受"value“参数（也显示为“value1“和”value2")，这些参数通常被理解为被引用并在结果中成为 JSON 字符串值的文字字符串。

即使输入 value 字符串看起来像格式正确的 JSON，但它们在结果中仍被解释为字符串。

然而，如果一个 value 参数直接来自另一个 JSON 函数的结果或来自 `->` 运算符，则该参数被理解为实际 JSON 并插入完整的 JSON 而不是带引号的字符串。

**示例**

```
json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$') → '{"a":2,"c":[4,5,{"f":7}]}'
json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$.c') → '[4,5,{"f":7}]'
json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$.c[2]') → '{"f":7}'
json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$.c[2].f') → 7
json_extract('{"a":2,"c":[4,5],"f":7}','$.c','$.a') → '[[4,5],2]'
json_extract('{"a":2,"c":[4,5],"f":7}','$.c[#-1]') → 5
json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$.x') → NULL
json_extract('{"a":2,"c":[4,5,{"f":7}]}', '$.x', '$.a') → '[null,2]'
json_extract('{"a":"xyz"}', '$.a') → 'xyz'
json_extract('{"a":null}', '$.a') → NULL

json_insert('[1,2,3,4]','$[#]',99) → '[1,2,3,4,99]'
json_insert('[1,[2,3],4]','$[1][#]',99) → '[1,[2,3,99],4]'

json_insert('{"a":2,"c":4}', '$.a', 99) → '{"a":2,"c":4}'
json_insert('{"a":2,"c":4}', '$.e', 99) → '{"a":2,"c":4,"e":99}'

json_replace('{"a":2,"c":4}', '$.a', 99) → '{"a":99,"c":4}'
json_replace('{"a":2,"c":4}', '$.e', 99) → '{"a":2,"c":4}'

json_set('{"a":2,"c":4}', '$.a', 99) → '{"a":99,"c":4}'
json_set('{"a":2,"c":4}', '$.e', 99) → '{"a":2,"c":4,"e":99}'
json_set('{"a":2,"c":4}', '$.c', '[97,96]') → '{"a":2,"c":"[97,96]"}'
json_set('{"a":2,"c":4}', '$.c', json('[97,96]')) → '{"a":2,"c":[97,96]}'
json_set('{"a":2,"c":4}', '$.c', json_array(97,96)) → '{"a":2,"c":[97,96]}'

json_object('a',2,'c',4) → '{"a":2,"c":4}'
json_object('a',2,'c','{e:5}') → '{"a":2,"c":"{e:5}"}'
json_object('a',2,'c',json_object('e',5)) → '{"a":2,"c":{"e":5}}'

json_remove('[0,1,2,3,4]','$[2]') → '[0,1,3,4]'
json_remove('[0,1,2,3,4]','$[2]','$[0]') → '[1,3,4]'
json_remove('[0,1,2,3,4]','$[0]','$[2]') → '[1,2,4]'
json_remove('[0,1,2,3,4]','$[#-1]','$[0]') → '[1,2,3]'
json_remove('{"x":25,"y":42}') → '{"x":25,"y":42}'
json_remove('{"x":25,"y":42}','$.z') → '{"x":25,"y":42}'
json_remove('{"x":25,"y":42}','$.y') → '{"x":25}'
json_remove('{"x":25,"y":42}','$') → NULL
```