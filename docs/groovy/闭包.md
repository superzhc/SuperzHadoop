# 闭包

## 定义闭包

**语法**

```groovy
{ [closureParameters -> ] statements }
```

语法中，`[ closureParameters -> ]` 代表参数列表，参数可以是 0 个或多个，且是否声明参数类型是可选的。如果声明了参数列表，则 `->` 是必须存在的，用以区分参数和执行语句。statements 代表执行语句，一般情况下都有至少一条执行逻辑（可以没有）。

*示例【合法的闭包示例】*

```groovy
{} // 接收一个参数，空执行语句

{ ++it } // 接收一个参数，默认it

{ -> println('no param')} // 没有参数，必须写 ->

// 可以声明参数类型
{ String x, int y -> println("x is ${x}, y is ${y}") }

// 可以省略参数类型
{ x, y -> println("x is ${x}, y is ${y}") }

// 一个参数，多行执行语句
{ x ->
    int y = -x
    println("-x is ${y}")
}
```

**`groovy.lang.Closure` 对象**

> 定义的闭包是一个 Closure 对象，可以把一个闭包赋值给一个变量

```groovy
def hello = { String x ->
    printf("hello ${x}")
}
```

## 使用闭包

> 可以像方法一样调用一个闭包，也可以显式地通过 call 方法调用

```groovy
def isOdd = { int i -> i%2 != 0 }
assert isOdd(3) == true // 类似方法调用
assert isOdd.call(2) == false // 使用call方法
```

## 向闭包传递参数

### 隐藏参数

> 闭包没有显示定义参数列表时（ 隐藏 `->` 符号时 ），闭包会默认提供一个名为 `it` 的参数，可以在执行语句中使用该参数。

## 闭包属性

> 在闭包内部，有三个内置属性 `this`，`owner`，`delegate`，可以直接 `this`，`owner`，`delegate` 调用，或者用 get 方法，`getThisObject()`，`getOwner()`，`getDelegate()`。
>
> - `this` 对应于定义闭包的类，如果在内部类中定义，指向的是内部类
> - `owenr` 对应于定义闭包的类或者闭包，如果在闭包中定义，对应闭包，否则同 `this` 一致
> - `delegate` 默认是和 `owner` 一致，或者自定义 `delegate` 指向

*示例*

```groovy
class OuterClass {
    class InnerClass {

        def outerClosure = {
            def innerClosure = {
            }
            printfMsg("innerClosure", innerClosure)
            println("------")
            printfMsg("outerClosure", outerClosure)
        }

        void printfMsg(String flag, Closure closure) {
            def thisObject = closure.getThisObject()
            def ownerObject = closure.getOwner()
            def delegate = closure.getDelegate()
            println("${flag} this: ${thisObject.toString()}")
            println("${flag} owner: ${ownerObject.toString()}")
            println("${flag} delegate: ${delegate.toString()}")
        }
    }

    def callInnerMethod() {
        def innerClass = new InnerClass()
        innerClass.outerClosure.call()
        println("------")
        println("outerClosure toString ${innerClass.outerClosure.toString()}")
    }

    static void main(String[] args) {
        new OuterClass().callInnerMethod()
    }
}
```