# NameNode

## 关于NameNode中的元信息

当一个客户端请求一个文件或者存储一个文件时，它需要先知道具体到哪个 DataNode 上存取，获得这些信息后，客户端再直接和这个 DataNode 进行交互，而这些信息的维护者就是 NameNode。

**NameNode管理着文件系统命名空间，它维护这文件系统树及树中的所有文件和目录**。NameNode也负责维护所有这些文件或目录的打开、关闭、移动、重命名等操作。对于实际文件数据的保存与操作，都是由 DataNode 负责。当一个客户端请求数据时，它仅仅是从 NameNode 中获取文件的元信息，而具体的数据传输不需要经过 NameNode，是由客户端直接与相应的 DataNode 进行交互。

NameNode保存元信息的种类有：

- 文件名目录名及它们之间的层级关系
- 文件目录的所有者及其权限
- 每个文件块的名及文件有哪些块组成

需要注意的是，**NameNode元信息并不包含每个块的位置信息**，这些信息会在 NameNode 启动时从各个 DataNode 获取并保存在内存中，因为这些信息会在系统启动时由数据节点重建。把块位置信息放在内存中，在读取数据时会减少查询时间，增加读取效率。NameNode 也会实时通过心跳机制和 DataNode 进行交互，实时检查文件系统是否运行正常。不过 NameNode 元信息会保存各个块的名称及文件由哪些块组成。

一般来说，一条元信息记录会占用 200byte 内存空间。假设块大小为 64MB，备份数量是3 ，那么一个 1GB 大小的文件将占用`16*3=48` 个文件块。如果现在有 1000 个 1MB 大小的文件，则会占用 `1000*3=3000` 个文件块（多个文件不能放到一个块中）。我们可以发现，如果文件越小，存储同等大小文件所需要的元信息就越多，所以 Hadoop 不适合存储小文件。

## 元信息的持久化

在 NameNode 中存放元信息的文件是 `fsimage`。在系统运行期间所有对元信息的操作都保存在内存中并被持久化到另一个文件`edits` 中。并且 `edits` 文件和 `fsimage` 文件会被 SecondaryNameNode 周期性的合并。

## 其它问题

运行 NameNode 会占用大量内存和 I/O 资源，一般 NameNode 不会存储用户数据或执行 MapReduce 任务。

为了简化系统的设计，Hadoop 只有一个 NameNode，这也就导致了 Hadoop 集群的单点故障问题。因此，对 NameNode 节点的容错尤其重要，Hadoop提供了如下两种机制来解决：

- 将 Hadoop 元数据写入到本地文件系统的同时再实时同步到一个远程挂载的网络文件系统（NFS）。
- 运行一个Secondary NameNode，它的作用是与 NameNode 进行交互，定期通过编辑日志文件合并命名空间镜像，当NameNode 发生故障时它会通过自己合并的命名空间镜像副本来恢复。需要注意的是 SecondaryNameNode 保存的状态总是滞后于 NameNode，所以这种方式难免会导致丢失部分数据。



