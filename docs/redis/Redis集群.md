# Redis 集群

- [Redis 集群](#redis-集群)
  - [Redis 集群的 TCP 端口](#redis-集群的-tcp-端口)
  - [Redis 集群以及 Docker](#redis-集群以及-docker)
  - [Redis 集群数据分片](#redis-集群数据分片)
  - [Redis 集群主从模式](#redis-集群主从模式)
  - [Redis 集群的一致性保证](#redis-集群的一致性保证)
  - [Redis 集群配置参数](#redis-集群配置参数)
  - [创建及使用Redis集群](#创建及使用redis集群)
  - [创建集群](#创建集群)
  - [集群的客户端](#集群的客户端)

Redis 集群使用过程中数据会自动共享到其他的 Redis 节点中，同时在分区上提供了一定程度上的可用性，也就是在实际中某些节点失败或者无法通信时操作仍然能够继续执行的能力（例如当大多数的主服务器都不可用时）。

Redis 集群的功能：
- 自动将数据切分到多个节点的能力
- 当集群中部分节点服务器瘫痪或者无法通信时，仍然能够继续处理请求命令的能力

## Redis 集群的 TCP 端口

Redis 集群的每个节点都需要打开两个 TCP 连接。例如，通常用于服务客户端请求的Redis TCP端口是6379，以及通过用6379 端口数加上 10000 而得到的端口 16379。第二个高位端口用于集群总线，是使用二进制协议协议进行点对点的通信信道。集群总线在各节点用于失败监听，配置更新，故障转移授权等等。客户端不应该尝试与集群总线的端口通信，应该只允许和 Redis 的命令端口，即低位端口 6379 进行通信。但是要保证防火墙开放这两个端口，否则 Redis 集群节点将无法通信。

命令端口和集群总线端口的偏移量应固定为 10000。

注：若需要 Redis 集群上的每个节点都能正常工作，需要满足：
1. 标准的客户通信端口（通常是 6379），用于与客户端通信，应对所有集群上可达的客户端，以及所有的其他 Redis 集群节点（其他节点用来做密钥迁移）开放。
2. 集群总线端口（客户端加10000）在其他集群节点是可达的。

如果不开放两个端口的话，集群将不会奏效。

集群总线采用一种不同的二进制协议进行点对点数据交换，这种协议更加适合用于少量带宽和处理时间的节点间的数据交换。

## Redis 集群以及 Docker

目前 Redis 集群不支持 NATted 环境以及 IP 地址或者端口会被重映射的一般环境

Docker 使用的是端口映射技术：在 Docker 容器内运行的程序可能会暴露在不同的端口上，相较于程序认为正在使用的那个端口而言。这对于同一时间，同一服务器上用相同的端口来运行多个容器是非常游泳的。为了让 Docker 与 Redis 集群相互兼容，需要使用 Docker 的 host networking mode（主机网络模式）。

## Redis 集群数据分片

Redis 集群不使用哈希一致性算法，而是使用一种不同的**分片（sharding）形式**，它的每一个 key 值在概念上都是 hash slot（哈希槽）的一部分。在 Redis 集群中有 16384 个哈希槽，要计算给定键的哈希槽，只需要对 16384 个哈希槽采用 CRC16 来模块化。

Redis集群中每一个节点负责一个子集的哈希槽，假如有三个节点的集群:
- Node A 包括 0 到 5500 的哈希槽。
- Node B 包括 5501 到 11000 的哈希槽。
- Node C 包括 11001 到 16383 的哈希槽。

这样便很容易在集群中添加和移除节点。例如，假如想要添加一个Node D，需要从节点A，B，C 中移动部分哈希槽分配给Node D ,类似地，假如想从集群移除Node A ,只需要将Node A 的哈希槽移动给B和C。当Node A为空时便可以完全地从集群移除该节点。

因为将哈希槽从一个节点移动到另一个节点不需要停止请求操作，添加和移除节点或者更改节点持有哈希槽的百分比也不需要停机等待。

Redis集群支持多个Key操作，只要所有涉及单个命令执行（或者整个事务或Lua脚本执行）的key都属于同一个哈希槽。用户可以使用名为**哈希标签**的概念强制多个Key成为相同哈希槽的一部分。

哈希标签的要点是如果有一个子串位于一个key值的`{}`括号中，且只有在这个子串里面的是散列的，例如，`this{foo}key` 和 `another{foo}key` 保证在同一个哈希槽中，并且能在多个Key的命令中一起作为参数使用。

## Redis 集群主从模式

当有一个子集的主节点服务瘫痪或者无法与其他大部分节点通信时，为了维持系统的可用性，Redis集群使用**主从模式**，即每一个哈希槽都有1到N个复制节点。(1个主节点，N-1个额外从节点)

在上面的例子中有节点A，B，C，假如Node B 瘫痪了集群也就无法继续工作了，因为无法再服务于5501-11000范围的哈希槽。

然而当为集群中的每个节点添加一个从节点之后，最终的集群则是由主节点A，B，C及它们的从节点A1，B1，C1组成，这时如果Node B瘫痪系统仍然可以继续运行。Node B1会替代Node B成为新的主节点并继续正常服务。

但是要记住如果B1和B都同时瘫痪了，redis集群照样无法继续正常服务。

## Redis 集群的一致性保证

Redis 集群是**无法保证强一致性**的。在实际中，这意味着在某些情况下Redis集群有可能会丢失写操作，尽管这个写操作系统确认已经反馈给客户端。Redis集群会丢失写操作的首要原因是使用了**异步的主从复制**。意思就是在写的过程中发生了以下情况:
1. 客户端写入到主节点B。
2. 主节点B反馈确认OK给客户端。
3. 主节点B传递写操作同步到从节点B1，B2，B3。
4. 正如你看到的主节点B在应答客户端之前并不会等待B1，B2，B3节点的确认反馈，可知对Redis而言这将是禁用延迟的代价，因此如果你的客户端写入内容，B响应反馈该写操作，但是在同步该写操作给它的从节点之前就崩溃了，其中一个从节点被提升为主节点，但是刚好这个从节点未接收到同步的写操作，则此次写入将永远丢失。

这个情况非常类似于多数配置成每秒定时刷新缓存到磁盘的数据库。类似地在应答客户端之前，通过强制数据库刷新缓存到磁盘以提升一致性，但是这样通常导致过多地性能损耗。那样就相当于是在集群的情况下使用同步复制了。

从根本上说，这是*性能和一致性之间的权衡*。

Redis集群在绝对需要时支持同步写入，通过 WAIT 命令来实现，这使得丢失写操作的可能性大大降低，但是记住即使是使用同步复制Redis集群依然不能满足强一致性。总是有可能会出现复杂的失败情况导致一台被选中替代主服务的从服务无法接收到写操作的同步的情况。

还有一种值得注意的情况，在一个网络分区中，一个客户端与少数实例(包括至少一个主)隔离的情况下，Redis集群将会丢失写入。

以我们的六节点A，B，C，A1，B1，C1为例，Z1表示客户端。分区之后，一部分分区是A，C，A1，B1，C1，另一部分是B和Z1。Z1仍然能够写入B。如果分区在短时间内恢复原状，集群将能继续正常工作。但是如果分区持续足够长时间，以至于（出现某些情况如B瘫痪）位于多节点网络分区的B1被提升为主节点，那么Z1发送给B的写入操作将会丢失。

注意假设Z1向B进行大量地写操作，在时间持续足够长的情况下，节点多的一边的分区发生了从节点替换节点少的分区的主节点，这将导致节点少的分区的主节点无法接收到写操作。

这个时间是Redis集群中非常重要的配置，称为**node timeout**（节点超时时间）。

当达到节点超时时间之后，主节点就会被认为已崩溃，并且可以由它的复制节点来替代它，但是如果该主节点无法检测到所在分区还有大多数的其他主节点，这时将会进入到一个错误的状态并停止接收写入操作。

## Redis 集群配置参数

我们将创建一个集群部署的示例。在这之前，先介绍下`redis.conf`文件里的集群配置参数。

- `cluster-enabled` `<yes/no>` : 若配置成yes则为一个特定的Redis实例启用集群。否则照常作为一个单独的实例启动。
- `cluster-config-file` `<filename>` : 注意先不管这个选项的名称，这不是一个用户可编辑的配置文件，但是Redis集群节点在每次发生变更时自动地持久化集群配置(基本上是状态)，为了能够在启动时重新读取它。这个文件列出了集群的其他节点，节点状态，持久化变量等等。接收到信息后该配置文件经常会被重写及刷新到磁盘中。
- `cluster-node-timeout` `<milliseconds>` : Redis 集群节点归为不可用的临界时间。若主节点超过指定时间不可达，它将被从节点替换。注意，每个超过指定的时间仍然无法联系上大多数的主节点的话，该节点将停止接收查询。
- `cluster-slave-validity-factor` `<factor>` : 如果设置为0，则从节点总是会故障切换主节点，不管主从节点之间的链接断开持续时间。如果该值是正数，将会根据配置的节点超时时间cluster-node-timeout和此处配的cluster-slave-validity-factor的乘积算出最大的断开时间，如果主从节点断开超过指定的时间，从节点将不会尝试故障切换主节点。例如，节点超时时间是5s，cluster-slave-validity-factor设置为10，从节点和主节点若是断开超过50s，它们之间将不会发生故障切换。记住，在某个主节点瘫痪又无法被从节点故障切换的情况下，该配置设为任何非0的值可能会导致集群不可用。在这种情况下只有原主节点重回集群，集群才能重新恢复可用。
- `cluster-migration-barrier` `<count>` : 满足迁移条件的主节点持有从节点的最小数量。满足该数量时，另一个主节点没有任何从节点的时候，该满足从节点最小持有数量的主节点的从节点将会迁移到无从节点的主节点下面。例如，主节点A持有3个从节点，集群中配置cluster-migration-barrier=2，主节点B下已经没有可用的从节点，则主节点A满足条件（3>2）可以将主节点A的其中一个从节点迁移到主节点B下。
- `cluster-require-full-coverage` `<yes/no>` : 默认设置为yes，如果集群有一定比例的哈希槽没有集群节点服务，集群将停止接收写操作，如果设置为no，即使只有一部分子集的哈希槽有节点在服务，集群仍然继续提供查询服务。

## 创建及使用Redis集群

*Redis 集群由多个运行在集群模式(cluster mode)下的 Redis 实例组成，实例的集群模式需要通过配置来开启，开启集群模式的实例将可以使用集群特有的功能和命令*。

注意：手动部署一个Redis集群最重要的是要学会操作它。然而，如果你想要尽快部署运行则可以跳过本节直接阅读 使用 create-cluster 脚本创建Redis集群 。

首先，我们需要在集群模式下有一些空的redis实例，这基本上意味着集群不是用普通的Redis实例创建的，因为需要配置一个特殊的模式，这样Redis实例就可以启用集群的特定功能和命令。

下面是一个最低的Redis集群配置文件:

```conf
port 7000
cluster-enabled yes
cluster-config-file nodes.conf
cluster-node-timeout 5000
appendonly yes
```

正如你看到的启用集群模式就是简单地设置 `cluster-enabled` 为 yes。每一个实例还包含了该路径下的一个节点配置存储文件`nodes.conf`。这个文件无须人为修改，是在Redis集群实例启动的时候生成的，并且会在每次需要的时候更新。

注意，最低要求的集群需要至少3个主节点才能正常工作。对于第一次尝试，非常建议使用6个集群节点，包括3个主节点和三个从节点。

进入到一个新的目录`cluster-test`，创建这些目录并以redis集群中各节点的实例对应的端口号命名，这些实例会在给定的目录中运行的。

就像这样:

```sh
mkdir cluster-test
cd cluster-test
mkdir 7000 7001 7002 7003 7004 7005
```

在每个目录中创建 `redis.conf` 文件，作为配置文件的模板，请使用上面的小示例，但是要保证替换成你的端口号。现在从GitHub的 unstable 分支获取redis源代码并编译成 redis-server 可执行文件，复制到 cluster-test 目录，在每一个总端tab中启动redis实例:

```
cd 7000
../redis-server ./redis.conf
```

如果`nodes.conf`文件不存在时，每个节点都会为自己分配一个新的ID：`[82462] 26 Nov 11:56:55.329 * No cluster configuration found, I'm 97a3a64667477371c4479320d683e4c8db5858b1`

这个ID将永远被这个特定的实例使用，以便在集群的环境中有一个唯一的名称。每个节点都会记住其他每个节点所使用的ID，而不是IP或者端口号。IP和端口号都是会变的，但是唯一节点标识符在节点的整个生命周期是不会变的，我们简单地称之为Node ID。

## 创建集群

现在我们有许多实例在运行了，我们需要通过编写一些有意义的配置来创建集群。通过**使用 Redis 集群命令行工具 redis-trib**很容易就能够实现，这是一个 Ruby 程序，这个程序通过向实例发送特殊命令来完成创建新集群，检查集群，或者对集群进行重新分片（reshared）工作。

redis-trib 在 Redis 源码包的 src 目录下。你需要安装 redisgem 才能运行 redis-trib。

```sh
gem install redis
```

创建你的集群只需简单地输入:

```sh
./redis-trib.rb create --replicas 1 127.0.0.1:7000 127.0.0.1:7001 127.0.0.1:7002 127.0.0.1:7003 127.0.0.1:7004 127.0.0.1:7005
```

这里使用的命令是create，因为我们是要创建一个集群。选项`--replicas 1`的意思是我们想要为每个主节点都创建一个从节点。其他的参数是用来创建集群的实例的地址列表。很明显这里我们创建了一个3个主节点3个从节点的集群。

Redis-trib接下来会向您推荐一个配置。输入yes表示接受。集群将会配置和连接，这意味着各个实例将引导彼此进行对话。最后如果没有报错，你将看到这段打印成功信息：

```
[OK] All 16384 slots covered
```

这段话意味着至少有一个主节点服务于16384个可用的哈希槽。

## 集群的客户端

- `redis-rb-cluster`
- `redis-py-cluster`
- Predis