# 虚拟机类加载机制

虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个声明周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备、解析 3 个部分统称为连接（Linking），这 7 个阶段的发生顺序如下图所示：

![img](images/161b466f3dcb07ca)

图中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的开始，而解析阶段则不一定。

## 类初始化的时机

对于类加载过程的第一个阶段：加载，jvm规范中并没有进行强制约束其开始时机，可交由jvm的具体实现来自由把握。但是对于初始化阶段，jvm规范严格规定了有且只有下列5种情况必须对类进行**“初始化”**（很自然地，加载、验证、准备需要在此之前开始）：

- 遇到`new`、`getstatic`、`putstatic`、`invokestatic`这四条字节码指令时，如果类没有进行过初始化，则必须先触发其初始化。最常见的生成这4条指令的场景是：**使用new关键字实例化对象**的时候；**读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）**的时候；以及**调用一个类的静态方法**的时候。
- 使用 `java.lang.reflect`包的方法对类进行**反射调用**的时候，如果类没有进行初始化，则需要先触发其初始化。
- 当初始化一个类的时候，如果发现其**父类**还没有进行过初始化，则需要先触发其父类的初始化。
- 当虚拟机启动时，用户需要制定一个要执行的**主类（包含main方法的那个类）**，虚拟机会先初始化这个主类；
- 当使用jdk1.7 的**动态语言支持**时，如果一个`java.lang.invoke.MethodHandle`实例最后的解析结果`REF_getStatic`, `REF_putStatic`, `REF_invokeStatic` 的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化；

以上5种场景中的行为称为对一个类进行**主动引用**。除此之外，所有引用类的方式都不会触发初始化，称为**被动引用**。被动引用的常见例子包括：

- 通过子类引用**父类的静态字段**，不会导致子类初始化。
- 通过**数组定义**来引用类，不会触发此类的初始化，如`SuperClass[] sca = new SuperClass[10];`。
- **常量**在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。

**接口的加载过程**和类加载过程略有不同，它们真正的区别在于在前文提到的5种需要开始初始化场景中的第3种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其**父接口**全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。

## 类加载的过程

### 加载

在加载阶段，虚拟机需要完成以下 3 件事情：

1. 通过一个类的全限定名来获取定义此类的二进制字节流
2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构
3. 在内存中生成一个代表这个类的 `java.lang.Class` 对象，作为方法区这个类的各种数据的访问入口

这三点要求不算具体，在jvm实现时灵活度很大。例如上面的第一条，它没有指明二进制字节流要从一个Class文件中获取，准确地说没有指明要从哪里获取、怎样获取。这也为许多Java技术提供了基础，例如：

- 从ZIP包读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。
- 从网络中获取，这种场景最典型的应用是Applet。
- 运行时计算生成，这种场景使用得最多得就是**动态代理**技术，在`java.lang.reflect.Proxy`中，就是用了`ProxyGenerator.generateProxyClass`的代理类的二进制字节流。
- 由其他文件生成，典型场景是**JSP应用**，即由JSP文件生成对应的Class类。
- 从数据库读取，这种场景相对少见，例如有些**中间件服务器**（如SAP Netweaver）可以选择把程序安装到数据库中来完成程序代码在集群间的分发。

### 验证

连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

大致完成4个阶段的检验动作：文件格式验证、元数据验证、字节码验证、符号引用验证。

**1. 文件格式验证**

第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。这一阶段可能包括下面这些验证点：

- 是否以魔数0xCAFEBABE开头。
- 主次版本号是否在当前虚拟机的处理范围之内
- 常量池的常量中是否有不被支持的常量类型（tag标志）。
- 指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量。
- Class文件中各个部分及文件本身是否有被删除的或附加的其他信息。 ……

这阶段的验证是**基于二进制字节流**进行的，只有通过了这个阶段的验证后，字节流才会**进入方法区中进行存储**，所以后面的3个验证阶段全部是基于方法区的存储结构进行的，不会再直接操作字节流。

**2. 元数据验证**

第二阶段是对**字节码描述的信息（即类的元数据信息）**进行**语义分析**，以保证其描述的信息符合Java语言规范的要求。例如下面这些验证点：

- 该类是否有父类（除了`java.lang.Object`之外，所有的类都应有父类）
- 该类的父类是否继承了不允许被继承的类（final修饰的类）
- 若此类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法 ……

该阶段的主要目的是对类的元数据信息进行**语义检验**，保证不存在不符合Java语言规范的元数据信息。

**3. 字节码验证**

第三阶段的主要目的是**进行数据流和控制流分析**，确定程序**语义**是合法的、符合逻辑的。在**第二阶段**对元数据信息中的**数据类型**做完校验之后，这个阶段将对**类的方法体**进行校验分析，以保证**被校验类的方法**在运行时不会做出危害虚拟机安全的行为。例如：

- 保证任意时刻操作数栈的**数据类型**与**指令代码序列**都能配合工作。
- 保证**跳转指令**不会跳转到方法体以外的字节码指令上。
- 保证**方法体中类型转换**是有效的，例如子类对象可以赋值给父类数据类型，但父类对象赋值给子类数据类型是危险和不合法的。 ……

**4. 符号引用验证**

最后一个阶段的校验发生在虚拟机将**符号引用**转化为**直接引用**的时候，**这个转化动作将在连接的第三阶段——解析阶段中发生**。符号引用验证可以看做是**对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验**，通常需要校验下列内容：

- 符号引用中通过字符串描述的全限定名是否能找到对应的类。
- 指定的类中是否存在符合描述符与简单名称描述的方法与字段。
- 符号引用中的类、字段、方法的**访问性**（private、protected、public、default）是否可被当前类访问。 ……

符号引用的目的是**确保解析动作能正常执行**。

对于jvm的类加载机制来说，验证阶段是一个非常重要但不是一定必要（因为对运行期没有影响）的阶段。如果所运行的全部代码都已经被反复验证过，那么在实施阶段就可以考虑使用`-Xverify:none`参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。

### 准备

准备阶段的主要任务是如下两点：

- **为类变量分配内存**
- **设置类变量初始值**

这些变量所使用的内存都将在**方法区**中分配。

首先，在准备阶段进行内存分配的仅包括**类变量（被static修饰的变量）**，而不包括**实例变量**，实例变量将会在**对象实例化**时随着对象一起分配在Java堆中。

### 解析

解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。

- 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时无歧义地定位到目标即可，与虚拟机实现的内存布局无关，引用的目标并不一定以及加载到内存中。
- 直接引用：直接引用可以直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局相关的。引用的目标必定已存在于内存中。

在16个用于操作符号引用的字节码指令之前，先对它们所使用的符号引用进行解析。所有虚拟机实现可以根据需要来判断到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用之前才去解析它。

解析动作主要针对类或接口、字段、类方法、方法类型、方法句柄和调用点限定符7类符号引用进行解析。

### 初始化　

初始化阶段是类加载过程的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码（或者说是字节码）。

在准备阶段，变量已经赋过一次系统要求的初始值，而在初始阶段，则根据查询员通过查询制定的主观计划去初始化变量和其他资源，换而言之，初始化阶段是执行类类构造器 `<client>()` 方法的过程。

在 `<client>()` 方法中，静态语句块中只能访问到定义在静态语句块之前的变量，定义在他之后的变量，在前面的静态语句块可以赋值，但不能访问。