# 垃圾收集器

> 垃圾收集器是垃圾算法的具体实现。Java 虚拟机规范中对垃圾收集器应该如何实现并没有任何规定，因此不同的厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别，并且一般都会提供参数供用户根据自己的应用特点和要求组合出各个年代所使用的收集器。

基于 JDK1.7 Update 14 之后的 Hotspot 虚拟机包含的所有收集器：

![HotSpot收集器](D:\superz\BigData-A-Question\JVM\垃圾收集\images\HotSpot收集器.png)

上图展示了 7 种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。垃圾收集器所处的区域，则表示它是属于新生代收集器还是老年代收集器。

## Serial 收集器

这个收集器是一个单线程的收集器，它只会使用一个 CPU 或一条收集线程去完成垃圾收集工作，并且在它进行垃圾收集时，必须暂停其他所有的工作线程（Stop The World），直到它收集结束。

Stop The World 这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，这对于很多应用来说都是难以接受的，但这个矛盾并没办法消除，只能将用户线程的停顿时间在不断的缩减。

Serial 收集器相比较于其他收集器，在单线程下是**简单且高效**的，对于限定单个 CPU 的环境来说，Serial 收集器由于没有线程交互的开销，因此可以获得最高的单线程收集效率。

## ParNew 收集器

ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括 Serial 收集器可用的所有控制参数（例如：`-XX:SurvivorRatio`、`-XX:PretenureSizeThreshold`、`-XX:HandlePromotionFailure` 等）、收集算法、Stop The World、对象分配规则、回收策略等都与 Serial 收集器完全一样，在实现上，这两种收集器也共用了相当多的代码。

## Parallel Scavenge 收集器

Parallel Scavenge 收集器是一个新生代收集器，它是使用复制算法的收集器，也是并行的多线程收集器。

Parallel Scavenge 收集器的目标是达到一个可控制的吞吐量（Throughput），所谓吞吐量就是 CPU 用于运行用户代码的时间与 CPU 总消耗时间的比值，即 `吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间）`。

Parallel Scavenge 收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的 `-XX:MaxGCPauseMillis` 参数以及直接设置吞吐量大小的 `-XX:GCTimeRatio` 参数。

## Serial Old 收集器

Serial Old 是 Serial 收集器的老年代版本，它同样是一个单线程收集器，使用**标记-整理**算法。

## Parallel Old 收集器

Parallel Old 是 Parallel Scavenge 收集器的老年代版本，使用多线程和**标记-整理**算法。

## CMS 收集器

CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。

CMS 收集器是基于**标记-清除**算法实现的，它的运作过程相对于前面几种收集器来说更复杂一点，整个过程分为 4 个步骤，包括：

- 初始标记（CMS initial mark）
- 并发标记（CMS concurrent mark）
- 重新标记（CMS remark）
- 并发清除（CMS concurrent sweep）

其中，初始标记、重新标记这两个步骤仍然需要 `Stop The World`。初始标记仅仅只是标记一下 GC Roots 能直接关联到的对象，速度非常快，并发标记阶段就是进行 GC Roots Tracing 的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。

由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所以，从总体上来说，CMS 收集器的内存回收过程是与用户线程一起并发执行的。

CMS 收集器的缺点：

- 对 CPU 资源敏感：默认分配的垃圾收集线程数为 `（CPU 数+3）/4`，随着 CPU 数量下降，占用 CPU 资源越多，吞吐量越小
- 无法处理浮动垃圾：在并发清理阶段，由于用户线程还在运行，还会不断产生新的垃圾，CMS 收集器无法在当次收集中清除这部分垃圾。同时由于在垃圾收集阶段用户线程也在并发执行，CMS 收集器不能像其他收集器那样等老年代被填满时再进行收集，需要预留一部分空间提供用户线程运行使用。当 CMS 运行时，预留的内存空间无法满足用户线程的需要，就会出现 “ Concurrent Mode Failure ”的错误，这时将会启动后备预案，临时用 Serial Old 来重新进行老年代的垃圾收集。
- 因为 CMS 是基于标记-清除算法，所以垃圾回收后会产生空间碎片，可以通过 -XX:UserCMSCompactAtFullCollection 开启碎片整理（默认开启），在 CMS 进行 Full GC 之前，会进行内存碎片的整理。还可以用 -XX:CMSFullGCsBeforeCompaction 设置执行多少次不压缩（不进行碎片整理）的 Full GC 之后，跟着来一次带压缩（碎片整理）的 Full GC。

## G1 收集器

G1 收集器是 jdk1.7 才正式引用的商用收集器，现在已经成为 jdk9 默认的收集器。前面几款收集器收集的范围都是新生代或者老年代，G1 进行垃圾收集的范围是整个堆内存，它采用 **化整为零** 的思路，把整个堆内存划分为多个大小相等的独立区域（Region），在 G1 收集器中还保留着新生代和老年代的概念，它们分别都是一部分 Region，如下图：

![image-20200409230406142](D:\superz\BigData-A-Question\JVM\垃圾收集\images\image-20200409230406142.png)

每一个方块就是一个区域，每个区域可能是 Eden、Survivor、老年代，每种区域的数量也不一定。JVM 启动时会自动设置每个区域的大小（1M ~ 32M，必须是 2 的次幂），最多可以设置 2048 个区域（即支持的最大堆内存为 32M*2048 = 64G），假如设置 `-Xmx8g -Xms8g`，则每个区域大小为 8g/2048=4M。

为了在 GC Roots Tracing 的时候避免扫描全堆，在每个 Region 中，都有一个 Remembered Set 来实时记录该区域内的引用类型数据与其他区域数据的引用关系（在前面的几款分代收集中，新生代、老年代中也有一个 Remembered Set 来实时记录与其他区域的引用关系），在标记时直接参考这些引用关系就可以知道这些对象是否应该被清除，而不用扫描全堆的数据。

G1 收集器可以 “ 建立可预测的停顿时间模型 ”，它维护了一个列表用于记录每个 Region 回收的价值大小（回收后获得的空间大小以及回收所需时间的经验值），这样可以保证 G1 收集器在有限的时间内可以获得最大的回收效率。

**如下图所示，G1 收集器收集器收集过程有初始标记、并发标记、最终标记、筛选回收，和 CMS 收集器前几步的收集过程很相似：**

![img](D:\superz\BigData-A-Question\JVM\垃圾收集\images\640.jpg)

1. **初始标记：**标记出 GC Roots 直接关联的对象，这个阶段速度较快，需要停止用户线程，单线程执行。
2. **并发标记：**从 GC Root 开始对堆中的对象进行可达新分析，找出存活对象，这个阶段耗时较长，但可以和用户线程并发执行。
3. **最终标记：**修正在并发标记阶段引用户程序执行而产生变动的标记记录。
4. **筛选回收：**筛选回收阶段会对各个 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来指定回收计划（用最少的时间来回收包含垃圾最多的区域，这就是 Garbage First 的由来——第一时间清理垃圾最多的区块），这里为了提高回收效率，并没有采用和用户线程并发执行的方式，而是停顿用户线程。

**适用场景：**要求尽可能可控 GC 停顿时间；内存占用较大的应用。

