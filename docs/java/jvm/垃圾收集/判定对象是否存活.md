# 判定对象是否存活

## 引用计数算法

> 给对象中添加一个引用计数器，没当有一个地方引用它时，计数器就加 1，当引用失效时，计数器值就减 1；任何时刻计数器都为 0 的对象就是不可能再被只用的。

**引用计数算法（Reference Counting）** 的实现简单，判定效率也很高，在大部分情况下它都是一个不错的算法，也有一些比较著名的应用案例，例如微软的 COM（Component Object Model）技术、使用 ActionScript 3 的 FlashPlayer、Python 语言以及在游戏脚本领域中被广泛应用的 Squirrel 中都使用了引用计数算法进行内存管理。但是，Java 语言中没有选用引用计数算法来管理内存，其中最主要的原因是 **它很难解决对象之间的相互循环引用的问题**。

## 根搜索算法

> 通过一系列的名为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为 **引用链（Reference Chain）** ，当一个对象到 GC Roots 没有任何引用链相连（用图论的话来说就是从 GC Roots 到这个对象不可达）时，则证明此对象是不可用的。

![GC_Roots](D:\superz\BigData-A-Question\JVM\垃圾收集\images\GC_Roots.png)

对象 obj9、obj10 虽然相互有关联，但是它们到 GC Roots 是不可达的，所以它们将会被判定为是可回收的对象。

在 Java 语言中，可作为 GC Roots 的对象包括下面几种：
- 在虚拟机栈 (栈帧中的本地变量表) 中引用的对象，比如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。

- 在方法区中类静态属性引用的对象，比如Java类的引用类型静态变量。

- 在方法区中常量引用的对象，比如字符串常量池(String Table)里的引用。

- 在本地方法栈中JNI (即通常所说的Native方法) 引用的对象。
- Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象 (比如 NullPointExcepiton、OutOfMemoryError) 等，还有系统类加载器。
- 所有被同步锁 (synchronized关键字) 持有的对象。
- 反映Java虚拟机内部情况的 JM XBean、JVM TI 中注册的回调、本地代码缓存等。