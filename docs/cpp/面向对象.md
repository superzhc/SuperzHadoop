# 面向对象

## 类

### 类定义

```cpp
// class 关键字
class ClassName{
    Access specifiers:                            // 访问修饰符：private/public/protected
        type members/varibales;                   // 变量
        return_type functionName(parameterLists); // 方法
};                                                // 分号结束一个类的定义
```

**类成员函数**

> 成员函数可以定义在类定义内部，或者单独使用范围解析运算符（`::`）来定义。
>
> 在类定义中定义的成员函数把函数声明为内联的，即便没有使用 inline 标识符。


*示例*

```cpp
#include <iostream>
 
using namespace std;
 
class Box
{
   public:
      double length;         // 长度
      double breadth;        // 宽度
      double height;         // 高度
 
      // 成员函数声明
      double getVolume(void);
      void setLength( double len );
      void setBreadth( double bre );
      void setHeight( double hei );
};
 
// 成员函数定义
double Box::getVolume(void)
{
    return length * breadth * height;
}
 
void Box::setLength( double len )
{
    length = len;
}
 
void Box::setBreadth( double bre )
{
    breadth = bre;
}
 
void Box::setHeight( double hei )
{
    height = hei;
}
 
// 程序的主函数
int main( )
{
   Box box;                // 声明 Box，类型为 Box
   double volume = 0.0;     // 用于存储体积
 
   box.setLength(6.0); 
   box.setBreadth(7.0); 
   box.setHeight(5.0);
 
   // box 的体积
   volume = box.getVolume();
   cout << "Box1 的体积：" << volume <<endl;
}
```

1. 在范围解析运算符（`::`）之前必须使用类名

**构造函数/析构函数**

```cpp
class MyClass{
    public:
        // 构造函数声明
        MyClass();
        // 析构函数声明
        ~MyClass();
}

// 构造函数定义
MyClass::MyClass(void){
    // do something
}

MyClass::~MyClass(void){
    // do something
}
```

注意：

1. 析构函数不会有返回值，也不能带有任何参数

**拷贝构造函数**

> 拷贝构造函数是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。

拷贝构造函数通常用于：

- 通过使用另一个同类型的对象来初始化新创建的对象
- 复制对象把它作为参数传递给函数
- 复制对象，并从函数返回这个对象

如果在类中没有定义拷贝构造函数，编译器会自行定义一个。如果类带有指针变量，并有动态内存分配，则它必须有一个拷贝构造函数。拷贝构造函数的最常见形式如下：

```cpp
classname (const classname &obj) {
   // 构造函数的主体
}
```

**友元函数**

类的友元函数是定义在类外部，但有权访问类的所有私有（private）成员和保护（protected）成员。尽管友元函数的原型有在类的定义中出现过，但是友元函数并不是成员函数。

友元可以是一个函数，该函数被称为友元函数；友元也可以是一个类，该类被称为友元类，在这种情况下，整个类及其所有成员都是友元。

**内联函数**

C++ 内联函数是通常与类一起使用。如果一个函数是内联的，那么在编译时，编译器会把该函数的代码副本放置在每个调用该函数的地方。

对内联函数进行任何修改，都需要重新编译函数的所有客户端，因为编译器需要重新更换一次所有的代码，否则将会继续使用旧的函数。

如果想把一个函数定义为内联函数，则需要在函数名前面放置关键字 inline，在调用函数之前需要对函数进行定义。如果已定义的函数多于一行，编译器会忽略 inline 限定符。

### 继承

一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：

```cpp
class derived-class: access-specifier base-class
```

其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称。如果未使用访问修饰符 access-specifier，则默认为 private。

**访问权限**

派生类可以访问基类中所有的非私有成员。

|          | public | protected | private |
| -------- | ------ | --------- | ------- |
| 同一个类 | yes    | yes       | yes     |
| 派生类   | yes    | yes       | no      |
| 外部的类 | yes    | no        | no      |

一个派生类继承了所有的基类方法，但下列情况除外：

- 基类的构造函数、析构函数和拷贝构造函数
- 基类的重载运算符
- 基类的友元函数

**继承类型**

当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。

当使用不同类型的继承时，遵循以下几个规则：

- 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。
- 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。
- 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。

**多继承**

多继承即一个子类可以有多个父类，它继承了多个父类的特性。

C++ 类可以从多个类继承成员，语法如下：

```cpp
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…
{
<派生类类体>
};
```

其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔。

### 运算符重载

重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。

```cpp
return_type operator<运算符>(参数列表)
```

**示例**

```cpp
Box operator+(const Box&);


```

## 对象

**定义对象**

通过类来定义对象，即创建对象

```cpp
ClassName obj;
```

**访问数据成员**

> 类的对象的公共数据成员可以使用直接成员访问运算符 `.` 来访问。