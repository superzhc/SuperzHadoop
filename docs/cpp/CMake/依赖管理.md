# 添加第三方依赖的方式

## 代码依赖

这种方式是直接将第三方库的完整代码直接添加到用户的项目中，当作项目代码的组成部分进行编译，这种方式会让第三方代码和用户代码混在一起，**不推荐使用**。

```txt
├── CMakeLists.txt
├── jsoncpp
│   ├── include
│   │   └── json
│   │       ├── autolink.h
│   │       ├── config.h
│   │       ├── features.h
│   │       ├── forwards.h
│   │       ├── json.h
│   │       ├── reader.h
│   │       ├── value.h
│   │       └── writer.h
│   ├── json_batchallocator.h
│   ├── json_internalarray.inl
│   ├── json_internalmap.inl
│   ├── json_reader.cpp
│   ├── json_value.cpp
│   ├── json_valueiterator.inl
│   └── json_writer.cpp
└── main.cpp
```

**`CMakeLists.txt`**

```txt
cmake_minimum_required(VERSION 3.17)
project(includes_full_code)
set(CMAKE_CXX_STANDARD 14)
# 包含头文件
include_directories(./jsoncpp/include)
set(jsoncpp jsoncpp/json_reader.cpp jsoncpp/json_writer.cpp jsoncpp/json_value.cpp)
# 添加可执行代码
add_executable(includes_full_code main.cpp ${jsoncpp})
```

## 内部工程依赖

内部工程依赖会把第三方库的管理职责交给第三方库工程的 `CMakeLists.txt`。

```txt
├── CMakeLists.txt
├── jsoncpp
│   ├── CMakeLists.txt
│   ├── include
│   │   └── json
│   │       ├── autolink.h
│   │       ├── config.h
│   │       ├── features.h
│   │       ├── forwards.h
│   │       ├── json.h
│   │       ├── reader.h
│   │       ├── value.h
│   │       └── writer.h
│   ├── json_batchallocator.h
│   ├── json_internalarray.inl
│   ├── json_internalmap.inl
│   ├── json_reader.cpp
│   ├── json_value.cpp
│   ├── json_valueiterator.inl
│   └── json_writer.cpp
└── main.cpp
```

**第三方库的 `CMakeLists.txt`**

```txt
cmake_minimum_required(VERSION 3.17)
project(jsoncpp)

add_library(${PROJECT_NAME} json_reader.cpp json_value.cpp json_writer.cpp)
target_include_directories(${PROJECT_NAME} PUBLIC ${PROJECT_SOURCE_DIR}/include)
```

**`CMakeLists.txt`**

```txt
cmake_minimum_required(VERSION 3.17)
project(multi_cmakelists)

# 添加子工程
add_subdirectory(jsoncpp)
# 链接子工程
target_link_libraries(${PROJECT_NAME} jsoncpp)

add_executable(${PROJECT_NAME} main.cpp)
```

> 这种方式除了引入第三方依赖，通常也会用这种方式来管理项目中的各个子模块，每个模块都有独立的 `CMakeLists.txt` 文件，从而实现子工程的单独引用。

## `find_library`：编译库方式引入

这种方式是用来依赖已经打包好的二进制文件，这种方式也分为静态库（`.a`、`.lib`）和动态库（`.so`、`.dll`）方式引入，这种方式也可以查找本机已经安装好的库。

```txt
├── CMakeLists.txt
├── jsoncpp
│   ├── include
│   │   └── json
│   │       ├── autolink.h
│   │       ├── config.h
│   │       ├── features.h
│   │       ├── forwards.h
│   │       ├── json.h
│   │       ├── reader.h
│   │       ├── value.h
│   │       └── writer.h
│   └── libjsoncpp.a
└── main.cpp
```

**`CMakeLists.txt`**

```txt
cmake_minimum_required(VERSION 3.17)
project(find_library_example)
include_directories(jsoncpp/include)
add_executable(${PROJECT_NAME} main.cpp)
find_library(jsoncpp_lib NAMES jsoncpp PATHS ./jsoncpp)
target_link_libraries(${PROJECT_NAME} ${jsoncpp_lib})
```

## `FetchContent`

FetchContent 是 cmake 3.11.0 版本开始提供的功能，可以非常方便用来添加第三方依赖。

```txt
├── CMakeLists.txt
└── main.cpp
```

**`CMakeLists.txt`**

```txt
cmake_minimum_required(VERSION 3.17)
project(fetch_content_example)
include(FetchContent)
#FetchContent_Declare(jsoncpp
#        GIT_REPOSITORY https://github.com/open-source-parsers/jsoncpp.git
#        GIT_TAG 1.9.4)
# 建议使用压缩包的方式依赖，下载速度更快
FetchContent_Declare(jsoncpp
        URL https://github.com/open-source-parsers/jsoncpp/archive/1.9.4.tar.gz)
FetchContent_MakeAvailable(jsoncpp)
add_executable(${PROJECT_NAME} main.cpp)
target_link_libraries(${PROJECT_NAME} jsoncpp_lib)
```

## CPM

CPM.cmake 是在 FetchContent 的基础上封装而来，相比 FetchContent 更加简单易用，使用 CPM 需要到 CPM.cmake 下载 cmake 目录的文件 CPM.cmake、get_cpm.cmake 和 testing.cmake，添加到项目当中。

```txt
├── CMakeLists.txt
├── cmake
│   ├── CPM.cmake
│   ├── get_cpm.cmake
│   └── testing.cmake
└── main.cpp
```

**`CMakeLists.txt`**

```txt
cmake_minimum_required(VERSION 3.17)
project(cpm_example)
include(cmake/CPM.cmake)
#CPMAddPackage(
#        GIT_REPOSITORY https://github.com/open-source-parsers/jsoncpp.git
#        GIT_TAG 1.9.4)
# 建议使用压缩包的方式依赖，下载速度更快
CPMAddPackage(
        NAME jsoncpp
        URL https://github.com/open-source-parsers/jsoncpp/archive/1.9.4.tar.gz)

add_executable(${PROJECT_NAME} main.cpp)
target_link_libraries(${PROJECT_NAME} jsoncpp_lib)
```

## find_package

find_package 是 cmake 3.19.0 版本开始提供的功能，可以非常方便添加，这种方式主要是从本机上查找 **已经安装好的库**，需要提前通过命令安装。

**语法**

```txt
find_package(<PackageName> [version] [EXACT] [QUIET] [MODULE]
             [REQUIRED] [[COMPONENTS] [components...]]
             [OPTIONAL_COMPONENTS components...]
             [NO_POLICY_SCOPE])
```

```txt
├── CMakeLists.txt
└── main.cpp
```

**`CMakeLists.txt`**

```txt
cmake_minimum_required(VERSION 3.17)
project(find_package_example)
find_package(jsoncpp REQUIRED)
add_executable(${PROJECT_NAME} main.cpp)
target_link_libraries(${PROJECT_NAME} jsoncpp_lib)
```