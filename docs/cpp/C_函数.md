# 函数

> 函数（function）是完成特定任务的独立程序代码单元。

C 语言中，一个函数由返回类型、函数名以及形式参数（简称形参）列表构成。在 C 语言标准中，又把函数名称作为函数标志。

**函数定义**

函数定义的一般形式为：

```
[存储类说明符] 返回类型 函数名(形参列表) 复合语句
```

在函数定义中，形参列表中的每个形参类型必须是完整的类型，返回类型也必须是完整类型或 void 类型。另外，存储类说明符只能用 `extern` 或 `static`，或者可缺省。如果缺省存储类说明符，则默认为 `extern`。`extern` 存储类说明符表示一个函数具有外部链接；`static` 存储类说明符表示一个函数具有内部链接。

## 函数原型（函数声明）

> 函数原型是一种声明形式，告知编译器正在使用某函数，因此函数原型也被称为 **函数声明**（function declaration）。
>
> 一个函数原型能确定该函数的一个比较完整的类型。

函数声明如下：

```
返回类型 函数名(形参列表);
```

形参列表中，每个形式参数用逗号分隔。另外可以用 `*` 表示变长数组类型，函数形参列表中每个形参的标识符(又称：变量名)可省。

## 函数参数

**无参数**

如果一个函数不含有任何形式参数，那么参数列表可用 `()` 或 `(void)` 表示。

**数组类型作为函数形参**

如果⼀个函数的形参是⼀个数组类型的对象，那么它会被调整为指向该数组元素类型的指针，同时如果类型还有限定符（⽐如 const、volatile），那么可以在表⽰数组对象的 `[]` ⾥添加。如果在 `[]` 中含有 static 关键字，那么实参必须确保⾄少能访问该形参所指定元素个数的元素数量。

对于⼀个纯函数声明⽽⾔（即声明该函数之后不直接对它定义），形参可以具有不完整类型，并且可以使⽤ `[*]` 来表⽰变长数组类型。

*示例*

```c
#include <stdio.h>

// 这⾥是对函数 Func1 的声明，不对它进⾏定义，因此可⽤ [*] 表示⼀个变⻓数组类型。
// 这⾥需要注意的是，a 的类型为 int[*]，它是⼀个不完整类型
static void Func1(int a[*]);

// 这⾥对函数 Func1 进⾏了定义，这⾥不能使⽤ [*]，但可以⽤ []。
// 因为 int[*] 是⼀个不完整类型，而 int[] 是完整类型，
// 因为 int[] 会被⾃动转换为 int*。当函数形参为数组类型时，会被⾃动转换为指向该数组元素类型的指针，所以这⾥的形参 a 就是 int* 类型
static void Func1(int a[])
{
    if(a != NULL)
        printf("a[0] = %d\n", a[0]);

    // 这⾥ sizeof(a) 的⼤⼩就相当于 sizeof(int*) 的大小
    printf("size of a = %zu\n", sizeof(a));
}

// 当⼀个数组类型对象作为函数形参时，⽆论指定数组⻓度是多少都不会有⽤。
// 因为它们都会被转换为指向该数组元素类型的指针。
// 这⾥的形参 a 也是 int* 类型
static void Func2(int a[10])
{
    if(a == NULL)
        puts("nil!");

    // 这⾥sizeof(a)的大小就相当于sizeof(int*)的大小
    printf("size of a = %zu\n", sizeof(a));
}

// 这⾥⽤ static 表示调⽤ Func3 时，实参所指定的数组或缓存应该⾄少含有 5 个 int 元素对象。
// 这⾥加上 const 限定符，表示对形参 a 做了常量限定，a 不能指向其他对象地址。
// 因此，这⾥ a 的类型为 int * const
static void Func3(int a[static const 5])
{
    int sum = 0;
    // 对数组元素求和
    for(int i = 0; i < 5; i++)
        sum += a[i];
    
    // OK
    a[0] = 100;

    // 这句话错误：a = NULL;，a不能指向其他对象，即a的值不能被修改
}

// 这⾥声明 Func4，其形参类型为⼀个元素类型为 int 的⼆维数组，
// 其中 a[i] 的类型被声明为 int[*]，是⼀个不确定个数的数组，
// 它是⼀个不完整类型
static void Func4(int a[static const 2][*]);

// 这⾥对 Func4 进⾏定义，并明确表示 a[i] 的类型为 int[3]。
// 对于⼀个函数形参类型为⼆维数组类型的也类似，
// 这⾥ a 的类型会被⾃动转换为 int(* const)[3]，即指向 int[3]数组的常量指针
static void Func4(int a[static const 2][3])
{
    // 这⾥将输出sizeof(int[3])⼀样的大小
    printf("size of a[0] = %zu\n", sizeof(*a));

    // 将a[1][2]的值修改为20
    a[1][2] = 20;

    // 这句话错误：a = NULL;，a的值不能被修改
}

int main(int argc, const char * argv[])
{
    // ⽤⼀个数组字⾯量作为实参来调⽤Func1
    Func1((int[]){ 1, 2 });

    // 这⾥直接⽤空值作为形参来调⽤Func2
    Func2(NULL);

    int array[] = { 1, 2, 3, 4, 5, 6 };

    // 将数组array作为实参来调⽤Func3
    Func3(array);

    // array的第⼀个元素被修改成了100
    printf("array[0] = %d\n", array[0]);

    int darray[][3] = {
        1, 2, 3,
        4, 5, 6
    };

    Func4(darray);
    // darray[1][2]的值被修改成了20
    printf("darray[1][2] = %d\n", darray[1][2]);
}
```

**带有不定参数类型及个数的函数声明与调用**

C 语言函数的形参类型列表的最后可以带有不定参数类型及个数的形参列表，用 `, ...` 来表示。

> C 语言标准明确规定，含有不定参数个数的形参列表中，必须要有一个确定的命名形参，并且不定参数只能放在最后面一个形参，并且 `...` 后不能再跟其他形参。

对于调用带有不定参数个数的函数时所要传递的实参而言，由于不定参数列表中的每个参数类型不确定，因此 C 语言编译器将采用默认的 *实参晋升*（argument promotion）机制。也就是说，*对于任何整数转换等级小于 int 类型的实参，其类型都将被晋升为 int 类型；单精度浮点类型（float）的实参将被晋升为双精度浮点类型（double）*。



## 函数栈空间

对于⼤部分处理器以及操作系统环境而言，每个函数都具有⾃⼰独⽴的上下⽂存储空间，此存储空间往往是栈式存储的，所以又被称为栈（stack）空间。相应地，⼀般处理器会有⼀个专⽤的栈指针寄存器（Stack Pointer Register，⼀般简称为 SP）⽤于存放当前函数所属的栈空间的地址。初始时，SP 会指向进程给当前程序分配栈空间的最⼤地址处。然后在函数中定义⼀个局部对象，那么它可能就会被保存在当前函数的栈空间中，此时栈指针 SP 会先减该局部对象所占存储空间的字节⼤⼩，然后将该对象的内容存放在此存储单元内。

## 内联函数

通常，函数调用都有一定的开销，因为函数的调用过程包括建立调用、传递参数、跳转到函数代码并返回。内联函数可以认为是将内联代码替换成函数调用。

使用 `inline` 关键字标识内联函数。