# 二叉树

> 二叉树（Binary Tree）是 $n (n \geq 0)$ 个结点的有限集合，该集合或者为空集（称为空二叉树），或者由**一个根节点**和**两棵互不相交的、分别称为根结点的左子树和右子树**的二叉树组成。

二叉树的特点：
- 每个结点最多有两棵子树，所以二叉树中不存在度大于 2 的结点。注意不是只有两棵子树，而是最多有。没有子树或者有一棵子树都是可以的
- 左子树和右子树是有顺序的，次序不能任意颠倒
- 即使树中某结点只有一棵子树，也要区分它是左子树还是右子树

二叉树具有五种基本形态：
- 空二叉树
- 只有一个根结点
- 根结点只有左子树
- 根结点只有右子树
- 根结点既有左子树又有右子树

二叉树的性质：

1. 性质1：**在二叉树的第 i 层上至多有 $2^{i-1}$ 个结点 ($i \geq 1$)**

   > 第一层是根结点，只有一个，所以 $2^{1-1}=2^{0}=1$
   >
   > 第二层有两个，$2^{2-1}=2^{1}=2$
   >
   > 第三层有四个，$2^{3-1}=2^{2}=4$
   >
   > 第四层有八个，$2^{4-1}=2^{3}=8$
   >
   > 通过数学归纳法的论证，可以得出在二叉树的第 i 层上至多有 $2^{i-1}$ 个结点 ($i \geq 1$)的结论

2. 性质2：**深度为 k 的二叉树至多有 $2^{k}-1$ 个结点 ($k \geq 1$)**

   > 深度为 k 意思就是有 k 层的二叉树。
   >
   > 如果有一层，至多 $1=2^{1}-1$ 个结点
   >
   > 如果有二层，至多 $1+2=2^{2}-1$ 个结点
   >
   > 如果有三层，至多 $1+2+4=2^{3}-1$ 个结点
   >
   > 如果有四层，至多 $1+2+4+8=2^{4}-1$ 个结点
   >
   > 通过数学归纳法的论证，可以得出，如果有 k 层，此二叉树至多有 $2^{k}-1$ 个结点

3. 性质3：**对任何一棵二叉树 T，如果其终端结点数为 $n_{0}$，度为 2 的结点数为 $n_{2}$，则 $n_{0}=n_{2}+1$**

4. 性质4：**具有 n 个结点的完全二叉树的深度为 $\left \lfloor log_{2}n \right \rfloor + 1$ ($\left \lfloor x \right \rfloor$ 表示不大于 x 的最大整数)**

5. 性质5：**如果对一棵有 n 个结点的完全二叉树（其深度为 $\left \lfloor log_{2}n \right \rfloor + 1$）的结点按层序编号（从第 1 层到第 $\left \lfloor log_{2}n \right \rfloor + 1$ 层，每层从左到右），对任一结点 i ($1 \leq i \leq n$) 有**：
   1. **如果 $i=1$，则结点 i 是二叉树的根，无双亲；如果 $i>1$，则其双亲是结点 $\left \lfloor i/2 \right \rfloor + 1$**
   2. **如果 $2i>n$，则结点 i 无左孩子（结点 i 为叶子结点）；否则其左孩子是结点 $2i$**
   3. **如果 $2i+1>n$，则结点 i 无右孩子；否则其右孩子是结点 $2i+1$**

二叉树遍历：

> **二叉树的遍历（traversing binary tree）是指从根结点出发，按照某种次序依次访问二叉树中所有结点，使得每个结点被访问以此且仅被访问一次**。

**二叉树遍历方法**

- 前序遍历
    规则是若二叉树为空，则空操作返回，否则先访问根结点，然后前序遍历左子树，再前序遍历右子树
    ![](https://gitee.com/superzchao/GraphBed/raw/master/publish/2020/数据结构/前序遍历.png)
- 中序遍历
    规则是若树为空，则空操作返回，否则从根结点开始（注意并不是先访问根结点），中序遍历根结点的左子树，然后是访问根结点，最后中序遍历右子树
    ![](https://gitee.com/superzchao/GraphBed/raw/master/publish/2020/数据结构/中序遍历.png)
- 后序遍历
    规则是若树为空，则空操作返回，否则从左到右先叶子后结点的方式遍历访问左右子树，最后是访问根结点
    ![](https://gitee.com/superzchao/GraphBed/raw/master/publish/2020/数据结构/后序遍历.png)
- 层序遍历
    规则是若树为空，则空操作返回，否则从树的第一层，也就是根结点开始访问，从上而下逐层遍历，在同一层中，按从左到右的顺序对结点逐个访问
    ![](https://gitee.com/superzchao/GraphBed/raw/master/publish/2020/数据结构/层序遍历.png)



二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构。

**二叉树的定义**：二叉树的每个结点至多只有二棵子树(不存在度大于 2 的结点)，二叉树的子树有左右之分，次序不能颠倒。二叉树的第 $i$ 层至多有 $2^{i-1}$ 个结点；深度为k的二叉树至多有 $2^{k-1}$个结点；对任何一棵二叉树T，如果其终端结点数为 $n_{0}$，度为2的结点数为 $n_{2}$，则 $n_{0}=n_{2}+1$。

**二叉树的示例**：

![img](D:\superz\BigData-A-Question\数据结构与算法\树\images\2009050402.jpg)

**满二叉树和完全二叉树：**

　　满二叉树：除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。

　　满二叉树的性质：

　　1) 一颗树深度为h，最大层数为k，深度与最大层数相同，k=h;

　　2) 叶子数为 $2^{h}$;

　　3) 第k层的结点数是：$2^{k-1}$;

　　4) 总结点数是：$2^{k-1}$，且总节点数一定是奇数。

　　完全二叉树：若设二叉树的深度为h，除第 h 层外，其它各层 (1～(h-1)层) 的结点数都达到最大个数，第h层所有的结点都连续集中在最左边，这就是完全二叉树。

　　**注：**完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。

![img](D:\superz\BigData-A-Question\数据结构与算法\树\images\141749056837546.png)

　　**二叉树的性质**：

　　1) 在非空二叉树中，第i层的结点总数不超过 $2^{i-1}, i>=1$;

　　2) 深度为h的二叉树最多有 $2^{h}-1$ 个结点(h>=1)，最少有h个结点;

　　3) 对于任意一棵二叉树，如果其叶结点数为 $N_{0}$，而度数为2的结点总数为 $N_{2}$，则 $N_{0}=N_{2}+1$;

　　4) 具有n个结点的完全二叉树的深度为 $log_{2}(n+1)$;

　　5)有N个结点的完全二叉树各结点如果用顺序方式存储，则结点之间有如下关系：

　　　　若I为结点编号则 如果I>1，则其父结点的编号为I/2；

　　　　如果2I<=N，则其左儿子（即左子树的根结点）的编号为2I；若2I>N，则无左儿子；

　　　　如果2I+1<=N，则其右儿子的结点编号为2I+1；若2I+1>N，则无右儿子。

　　6)给定N个节点，能构成h(N)种不同的二叉树，其中h(N)为卡特兰数的第N项，h(n)=C(2*n, n)/(n+1)。

　　7)设有i个枝点，I为所有枝点的道路长度总和，J为叶的道路长度总和 $J=I+2^{i}$。













